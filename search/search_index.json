{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knit \u00b6 A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. See the Getting Started guide to start using Knit.","title":"Home"},{"location":"#knit","text":"A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. See the Getting Started guide to start using Knit.","title":"Knit"},{"location":"controllers/","text":"Controllers Defined \u00b6 Controllers are singleton objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. A game might have many controllers. They serve as a core structure of the client within Knit. For the sake of example, we will develop a CameraController. For full API documentation, visit the Knit API page. Creating Controllers \u00b6 In its simplest form, a controller can be created like so: 1 2 3 local CameraController = Knit . CreateController { Name = \"CameraController\" } return CameraController The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = \"CameraController\" ). The last line ( return CameraController ) assumes this code is written in a ModuleScript, which is best practice for containing controllers. Adding methods \u00b6 Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. 1 2 3 4 5 6 7 function CameraController : LockTo ( part ) -- TODO: Lock camera end function CameraController : Unlock () -- TODO: Unlock end Adding properties \u00b6 Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: 1 2 CameraController . Distance = 20 CameraController . Locked = false Adding Basic Behavior \u00b6 Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. 1 2 3 4 5 6 7 8 9 10 11 12 function CameraController : LockTo ( part ) local cam = workspace . CurrentCamera self . Locked = true cam . CameraType = Enum . CameraType . Scriptable cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end function CameraController : Unlock () local cam = workspace . CurrentCamera self . Locked = false cam . CameraType = Enum . CameraType . Custom end More Behavior \u00b6 Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 CameraController . RenderName = \"CustomCamRender\" CameraController . Priority = Enum . RenderPriority . Camera . Value function CameraController : LockTo ( part ) if ( self . Locked ) then return end -- Stop if already locked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = true cam . CameraType = Enum . CameraType . Scriptable -- Bind to RenderStep: runService : BindToRenderStep ( self . RenderName , self . Priority , function () cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end ) end function CameraController : Unlock () if ( not self . Locked ) then return end -- Stop if already unlocked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = false cam . CameraType = Enum . CameraType . Custom -- Unbind: runService : UnbindFromRenderStep ( self . RenderName ) end Events \u00b6 What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. 1 2 3 4 5 6 7 8 9 10 11 12 13 local Signal = require ( Knit . Util . Signal ) CameraController . LockedChanged = Signal . new () function CameraController : LockTo ( part ) -- Other code... self . LockedChanged : Fire ( true ) end function CameraController : Unlock () -- Other code... self . LockedChanged : Fire ( false ) end Other code could then listen in for that event: 1 2 3 4 5 6 -- Somewhere else on the client local CameraController = Knit . Controllers . CameraController CameraController . LockedChanged : Connect ( function ( isLocked ) print ( isLocked and \"Camera is now locked\" or \"Camera was unlocked\" ) end ) Server Communication \u00b6 Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: 1 2 3 4 5 6 function CameraController : KnitStart () local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () SomeService . SomeEvent : Connect ( function (...) end ) SomeService . AnotherEvent : Fire ( \"Some data\" ) end KnitInit and KnitStart \u00b6 The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model . These methods an be added just like any other method: 1 2 3 4 5 6 7 function CameraController : KnitStart () print ( \"CameraController KnitStart called\" ) end function CameraController : KnitInit () print ( \"CameraController KnitInit called\" ) end","title":"Controllers"},{"location":"controllers/#controllers-defined","text":"Controllers are singleton objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. A game might have many controllers. They serve as a core structure of the client within Knit. For the sake of example, we will develop a CameraController. For full API documentation, visit the Knit API page.","title":"Controllers Defined"},{"location":"controllers/#creating-controllers","text":"In its simplest form, a controller can be created like so: 1 2 3 local CameraController = Knit . CreateController { Name = \"CameraController\" } return CameraController The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = \"CameraController\" ). The last line ( return CameraController ) assumes this code is written in a ModuleScript, which is best practice for containing controllers.","title":"Creating Controllers"},{"location":"controllers/#adding-methods","text":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. 1 2 3 4 5 6 7 function CameraController : LockTo ( part ) -- TODO: Lock camera end function CameraController : Unlock () -- TODO: Unlock end","title":"Adding methods"},{"location":"controllers/#adding-properties","text":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: 1 2 CameraController . Distance = 20 CameraController . Locked = false","title":"Adding properties"},{"location":"controllers/#adding-basic-behavior","text":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. 1 2 3 4 5 6 7 8 9 10 11 12 function CameraController : LockTo ( part ) local cam = workspace . CurrentCamera self . Locked = true cam . CameraType = Enum . CameraType . Scriptable cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end function CameraController : Unlock () local cam = workspace . CurrentCamera self . Locked = false cam . CameraType = Enum . CameraType . Custom end","title":"Adding Basic Behavior"},{"location":"controllers/#more-behavior","text":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 CameraController . RenderName = \"CustomCamRender\" CameraController . Priority = Enum . RenderPriority . Camera . Value function CameraController : LockTo ( part ) if ( self . Locked ) then return end -- Stop if already locked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = true cam . CameraType = Enum . CameraType . Scriptable -- Bind to RenderStep: runService : BindToRenderStep ( self . RenderName , self . Priority , function () cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end ) end function CameraController : Unlock () if ( not self . Locked ) then return end -- Stop if already unlocked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = false cam . CameraType = Enum . CameraType . Custom -- Unbind: runService : UnbindFromRenderStep ( self . RenderName ) end","title":"More Behavior"},{"location":"controllers/#events","text":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. 1 2 3 4 5 6 7 8 9 10 11 12 13 local Signal = require ( Knit . Util . Signal ) CameraController . LockedChanged = Signal . new () function CameraController : LockTo ( part ) -- Other code... self . LockedChanged : Fire ( true ) end function CameraController : Unlock () -- Other code... self . LockedChanged : Fire ( false ) end Other code could then listen in for that event: 1 2 3 4 5 6 -- Somewhere else on the client local CameraController = Knit . Controllers . CameraController CameraController . LockedChanged : Connect ( function ( isLocked ) print ( isLocked and \"Camera is now locked\" or \"Camera was unlocked\" ) end )","title":"Events"},{"location":"controllers/#server-communication","text":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: 1 2 3 4 5 6 function CameraController : KnitStart () local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () SomeService . SomeEvent : Connect ( function (...) end ) SomeService . AnotherEvent : Fire ( \"Some data\" ) end","title":"Server Communication"},{"location":"controllers/#knitinit-and-knitstart","text":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model . These methods an be added just like any other method: 1 2 3 4 5 6 7 function CameraController : KnitStart () print ( \"CameraController KnitStart called\" ) end function CameraController : KnitInit () print ( \"CameraController KnitInit called\" ) end","title":"KnitInit and KnitStart"},{"location":"examples/","text":"Start All Services \u00b6 A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script] Services [Folder] MyService [Module] AnotherService [Module] HelloService [Module] We can write our KnitRuntime script as such: 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services: for _ , v in ipairs ( script . Parent . Services : GetDescendants ()) do if ( v : IsA ( \"ModuleScript\" )) then require ( v ) end end Knit . Start (): Catch ( warn ) Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService : 1 2 3 4 5 6 7 8 9 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services within 'Services': Knit . AddServices ( script . Parent . Services ) -- Load all services (the Deep version scans all descendants of the passed instance): Knit . AddServicesDeep ( script . Parent . OtherServices ) Knit . Start (): Catch ( warn ) Tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function. Expose a Collection of Modules \u00b6 Like Knit.Util , we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules , we can expose this within our main runtime script: 1 2 3 4 5 6 7 8 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Expose our MyModules folder: Knit . MyModules = game : GetService ( \"ReplicatedStorage\" ). MyModules -- Load services/controllers Knit . Start () We can then use these modules elsewhere. For instance: 1 local SomeModule = require ( Knit . MyModules . SomeModule )","title":"Examples"},{"location":"examples/#start-all-services","text":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script] Services [Folder] MyService [Module] AnotherService [Module] HelloService [Module] We can write our KnitRuntime script as such: 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services: for _ , v in ipairs ( script . Parent . Services : GetDescendants ()) do if ( v : IsA ( \"ModuleScript\" )) then require ( v ) end end Knit . Start (): Catch ( warn ) Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService : 1 2 3 4 5 6 7 8 9 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services within 'Services': Knit . AddServices ( script . Parent . Services ) -- Load all services (the Deep version scans all descendants of the passed instance): Knit . AddServicesDeep ( script . Parent . OtherServices ) Knit . Start (): Catch ( warn ) Tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.","title":"Start All Services"},{"location":"examples/#expose-a-collection-of-modules","text":"Like Knit.Util , we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules , we can expose this within our main runtime script: 1 2 3 4 5 6 7 8 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Expose our MyModules folder: Knit . MyModules = game : GetService ( \"ReplicatedStorage\" ). MyModules -- Load services/controllers Knit . Start () We can then use these modules elsewhere. For instance: 1 local SomeModule = require ( Knit . MyModules . SomeModule )","title":"Expose a Collection of Modules"},{"location":"executionmodel/","text":"Order of Operations \u00b6 The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() , which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): Catch ( warn ) Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called. Catching KnitInit Errors \u00b6 Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: 1 2 3 4 5 local success , err = Knit . Start (): Await () if ( not success ) then -- Handle error error ( tostring ( err )) end 1 2 3 4 Knit . Start (): Catch ( function ( err ) -- Handle error warn ( tostring ( err )) end ) Best Practices \u00b6 Only one Script on the server should manage loading services and starting the Knit Only one LocalScript on the client should manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client Code within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possible Events and methods should never be added to a service's Client table after Knit.Start() has been called As shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup.","title":"Execution Model"},{"location":"executionmodel/#order-of-operations","text":"The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() , which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): Catch ( warn ) Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called.","title":"Order of Operations"},{"location":"executionmodel/#catching-knitinit-errors","text":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: 1 2 3 4 5 local success , err = Knit . Start (): Await () if ( not success ) then -- Handle error error ( tostring ( err )) end 1 2 3 4 Knit . Start (): Catch ( function ( err ) -- Handle error warn ( tostring ( err )) end )","title":"Catching KnitInit Errors"},{"location":"executionmodel/#best-practices","text":"Only one Script on the server should manage loading services and starting the Knit Only one LocalScript on the client should manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client Code within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possible Events and methods should never be added to a service's Client table after Knit.Start() has been called As shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup.","title":"Best Practices"},{"location":"gettingstarted/","text":"Install \u00b6 Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library. Place Knit directly within ReplicatedStorage. Rojo workflow: Download Knit from the latest release on GitHub. Extract the Knit directory from the zipped file. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage. Please note that it is vital for Knit to live directly within ReplicatedStorage. It cannot be nested in another instance, nor can it live in another service. This is due to other parts of Knit needing to reference back to the Knit module. Basic Usage \u00b6 The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 3 4 5 6 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'Await()' to the end to yield until the whole sequence is completed: -- Knit.Start():Catch(warn):Await() That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. A Simple Service \u00b6 A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money += amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): Catch ( warn ) Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ): Await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): Then ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"Getting Started"},{"location":"gettingstarted/#install","text":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library. Place Knit directly within ReplicatedStorage. Rojo workflow: Download Knit from the latest release on GitHub. Extract the Knit directory from the zipped file. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage. Please note that it is vital for Knit to live directly within ReplicatedStorage. It cannot be nested in another instance, nor can it live in another service. This is due to other parts of Knit needing to reference back to the Knit module.","title":"Install"},{"location":"gettingstarted/#basic-usage","text":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 3 4 5 6 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'Await()' to the end to yield until the whole sequence is completed: -- Knit.Start():Catch(warn):Await() That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples.","title":"Basic Usage"},{"location":"gettingstarted/#a-simple-service","text":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money += amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): Catch ( warn ) Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ): Await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): Then ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"A Simple Service"},{"location":"knitapi/","text":"Knit \u00b6 Knit.Services: [Service] \u00b6 [Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Controllers: Controller[] \u00b6 [Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Util: Folder \u00b6 A folder containing utility modules used by Knit, but also accessible for developers to use. This folder contains the following modules: Maid Event Promise Thread They can be required like any other module: 1 local Signal = require ( Knit . Util . Signal ) Knit.Start() -> Promise \u00b6 Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 11 12 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): Then ( function () print ( \"Knit is running\" ) end ): Catch ( function ( err ) warn ( err ) end ) Alternative ways to start Knit: 1 2 3 4 5 -- Use 'Await' to wait for Knit to start and capture any errors: local success , err = Knit . Start (): Await () if ( not success ) then warn ( err ) end 1 2 -- Feed the 'warn' built-in function directly to the Catch of the returned promise: Knit . Start (): Catch ( warn ) 1 2 3 -- Same as above, but also yield until Knit has started. -- Just note that the 'Catch' will eat up the error, so Await will return successfully even if an error occurs. Knit . Start (): Catch ( warn ): Await () It is important that errors are handled when starting Catch, as any errors within the Init lifecycle will go undetected otherwise. Knit.OnStart() -> Promise \u00b6 Wait for Knit to start. This is useful if there are other scripts that need to access Knit services or controllers. If Knit is already started, it resolves the promise immediately. 1 2 -- Wait for Knit to be started: Knit . OnStart (): Await () Knit.CreateService(service: ServiceDefinition) -> Service \u00b6 [Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} } Knit.AddServices(folder: Instance) \u00b6 [Server-side only] Automatically creates new services from ModuleScripts found directly within folder . 1 Knit . AddServices ( serverStorage . MyServices ) Knit.AddServicesDeep(folder: Instance) \u00b6 [Server-side only] Works the same as Knit.AddServices , but scans all descendants of folder . This is useful if services are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a service. If your services might have non-service modules nested in the descendant hierarchy, use a series of Knit.AddServices instead. 1 Knit . AddServicesDeep ( serverStorage . MyServices ) Knit.CreateController(controller: ControllerDefinition) -> Controller \u00b6 [Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" } Knit.AddControllers(folder: Instance) \u00b6 [Client-side only] Automatically creates new controllers from ModuleScripts found directly within folder . 1 Knit . AddControllers ( replicatedStorage . MyControllers ) Knit.AddControllersDeep(folder: Instance) \u00b6 [Client-side only] Works the same as Knit.AddControllers , but scans all descendants of folder . This is useful if controllers are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a controller. If your controllers might have non-controller modules nested in the descendant hierarchy, use a series of Knit.AddControllers instead. 1 Knit . AddControllersDeep ( replicatedStorage . MyControllers ) Knit.GetService(serviceName: string) -> ServiceMirror \u00b6 [Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): Then ( function () ... end ) Knit.GetController(controllerName: string) -> Controller \u00b6 [Client-side only] Returns a controller with the given controller name. This is just an alias for Knit.Controllers[controllerName] and only exists for developers who want to have the same pattern used with Knit.GetService . Service \u00b6 A service is a singleton object that serves a specific purpose on the server. Service.Name: string \u00b6 The name of the service. Service.Client: ServiceClient \u00b6 A ServiceClient table that contains client-exposed methods and events. Service:KnitInit() -> void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Service:KnitStart() -> void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Service.CUSTOM_FIELD: any \u00b6 Service:CUSTOM_METHOD(...) -> any \u00b6 Service.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceClient \u00b6 Refers to the the Client table within a service . ServiceClient.Server: Service \u00b6 A reference back to the top-level service . ServiceClient:CUSTOM_METHOD(player: Player, ...) -> any \u00b6 ServiceClient.CUSTOM_EVENT:Fire(player: Player, ...) -> void \u00b6 ServiceClient.CUSTOM_EVENT:FireAll(...) -> void \u00b6 ServiceClient.CUSTOM_EVENT:FireExcept(player: Player, ...) -> void \u00b6 Controller \u00b6 A controller is a singleton object that serves a specific purpose on the client. Controller.Name: string \u00b6 The name of the controller. Controller:KnitInit() -> void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Controller:KnitStart() -> void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Controller.CUSTOM_FIELD: any \u00b6 Controller:CUSTOM_METHOD(...) -> any \u00b6 Controller.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceMirror \u00b6 A table that mirrors the methods and events that were exposed on the server via the Client table. ServiceMirror:CUSTOM_METHOD(...) -> any \u00b6 ServiceMirror:CUSTOM_METHODPromise(...) -> Promise \u00b6 ServiceMirror.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -> void \u00b6","title":"Knit API"},{"location":"knitapi/#knit","text":"","title":"Knit"},{"location":"knitapi/#knitservices-service","text":"[Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Services: [Service]"},{"location":"knitapi/#knitcontrollers-controller","text":"[Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Controllers: Controller[]"},{"location":"knitapi/#knitutil-folder","text":"A folder containing utility modules used by Knit, but also accessible for developers to use. This folder contains the following modules: Maid Event Promise Thread They can be required like any other module: 1 local Signal = require ( Knit . Util . Signal )","title":"Knit.Util: Folder"},{"location":"knitapi/#knitstart-promise","text":"Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 11 12 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): Then ( function () print ( \"Knit is running\" ) end ): Catch ( function ( err ) warn ( err ) end ) Alternative ways to start Knit: 1 2 3 4 5 -- Use 'Await' to wait for Knit to start and capture any errors: local success , err = Knit . Start (): Await () if ( not success ) then warn ( err ) end 1 2 -- Feed the 'warn' built-in function directly to the Catch of the returned promise: Knit . Start (): Catch ( warn ) 1 2 3 -- Same as above, but also yield until Knit has started. -- Just note that the 'Catch' will eat up the error, so Await will return successfully even if an error occurs. Knit . Start (): Catch ( warn ): Await () It is important that errors are handled when starting Catch, as any errors within the Init lifecycle will go undetected otherwise.","title":"Knit.Start() -&gt; Promise"},{"location":"knitapi/#knitonstart-promise","text":"Wait for Knit to start. This is useful if there are other scripts that need to access Knit services or controllers. If Knit is already started, it resolves the promise immediately. 1 2 -- Wait for Knit to be started: Knit . OnStart (): Await ()","title":"Knit.OnStart() -&gt; Promise"},{"location":"knitapi/#knitcreateserviceservice-servicedefinition-service","text":"[Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} }","title":"Knit.CreateService(service: ServiceDefinition) -&gt; Service"},{"location":"knitapi/#knitaddservicesfolder-instance","text":"[Server-side only] Automatically creates new services from ModuleScripts found directly within folder . 1 Knit . AddServices ( serverStorage . MyServices )","title":"Knit.AddServices(folder: Instance)"},{"location":"knitapi/#knitaddservicesdeepfolder-instance","text":"[Server-side only] Works the same as Knit.AddServices , but scans all descendants of folder . This is useful if services are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a service. If your services might have non-service modules nested in the descendant hierarchy, use a series of Knit.AddServices instead. 1 Knit . AddServicesDeep ( serverStorage . MyServices )","title":"Knit.AddServicesDeep(folder: Instance)"},{"location":"knitapi/#knitcreatecontrollercontroller-controllerdefinition-controller","text":"[Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" }","title":"Knit.CreateController(controller: ControllerDefinition) -&gt; Controller"},{"location":"knitapi/#knitaddcontrollersfolder-instance","text":"[Client-side only] Automatically creates new controllers from ModuleScripts found directly within folder . 1 Knit . AddControllers ( replicatedStorage . MyControllers )","title":"Knit.AddControllers(folder: Instance)"},{"location":"knitapi/#knitaddcontrollersdeepfolder-instance","text":"[Client-side only] Works the same as Knit.AddControllers , but scans all descendants of folder . This is useful if controllers are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a controller. If your controllers might have non-controller modules nested in the descendant hierarchy, use a series of Knit.AddControllers instead. 1 Knit . AddControllersDeep ( replicatedStorage . MyControllers )","title":"Knit.AddControllersDeep(folder: Instance)"},{"location":"knitapi/#knitgetserviceservicename-string-servicemirror","text":"[Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): Then ( function () ... end )","title":"Knit.GetService(serviceName: string) -&gt; ServiceMirror"},{"location":"knitapi/#knitgetcontrollercontrollername-string-controller","text":"[Client-side only] Returns a controller with the given controller name. This is just an alias for Knit.Controllers[controllerName] and only exists for developers who want to have the same pattern used with Knit.GetService .","title":"Knit.GetController(controllerName: string) -&gt; Controller"},{"location":"knitapi/#service","text":"A service is a singleton object that serves a specific purpose on the server.","title":"Service"},{"location":"knitapi/#servicename-string","text":"The name of the service.","title":"Service.Name: string"},{"location":"knitapi/#serviceclient-serviceclient","text":"A ServiceClient table that contains client-exposed methods and events.","title":"Service.Client: ServiceClient"},{"location":"knitapi/#serviceknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Service:KnitInit() -&gt; void"},{"location":"knitapi/#serviceknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Service:KnitStart() -&gt; void"},{"location":"knitapi/#servicecustom_field-any","text":"","title":"Service.CUSTOM_FIELD: any"},{"location":"knitapi/#servicecustom_method-any","text":"","title":"Service:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#servicecustom_eventfire-void","text":"","title":"Service.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#serviceclient","text":"Refers to the the Client table within a service .","title":"ServiceClient"},{"location":"knitapi/#serviceclientserver-service","text":"A reference back to the top-level service .","title":"ServiceClient.Server: Service"},{"location":"knitapi/#serviceclientcustom_methodplayer-player-any","text":"","title":"ServiceClient:CUSTOM_METHOD(player: Player, ...) -&gt; any"},{"location":"knitapi/#serviceclientcustom_eventfireplayer-player-void","text":"","title":"ServiceClient.CUSTOM_EVENT:Fire(player: Player, ...) -&gt; void"},{"location":"knitapi/#serviceclientcustom_eventfireall-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireAll(...) -&gt; void"},{"location":"knitapi/#serviceclientcustom_eventfireexceptplayer-player-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireExcept(player: Player, ...) -&gt; void"},{"location":"knitapi/#controller","text":"A controller is a singleton object that serves a specific purpose on the client.","title":"Controller"},{"location":"knitapi/#controllername-string","text":"The name of the controller.","title":"Controller.Name: string"},{"location":"knitapi/#controllerknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Controller:KnitInit() -&gt; void"},{"location":"knitapi/#controllerknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Controller:KnitStart() -&gt; void"},{"location":"knitapi/#controllercustom_field-any","text":"","title":"Controller.CUSTOM_FIELD: any"},{"location":"knitapi/#controllercustom_method-any","text":"","title":"Controller:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#controllercustom_eventfire-void","text":"","title":"Controller.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#servicemirror","text":"A table that mirrors the methods and events that were exposed on the server via the Client table.","title":"ServiceMirror"},{"location":"knitapi/#servicemirrorcustom_method-any","text":"","title":"ServiceMirror:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#servicemirrorcustom_methodpromise-promise","text":"","title":"ServiceMirror:CUSTOM_METHODPromise(...) -&gt; Promise"},{"location":"knitapi/#servicemirrorcustom_eventfire-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#servicemirrorcustom_eventconnectfunction-end-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -&gt; void"},{"location":"services/","text":"Services Defined \u00b6 Services are singleton objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page. Creating Services \u00b6 In its simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services. Adding methods \u00b6 Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end Adding properties \u00b6 Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {} Using methods and properties \u00b6 Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points += amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end Using events \u00b6 What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Signal module and create PointsChanged signal: local Signal = require ( Knit . Util . Signal ) PointsService . PointsChanged = Signal . new () -- Modify AddPoints: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points -- Fire event signal, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end KnitInit and KnitStart \u00b6 In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up you service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. Cleaning Up Unused Memory \u00b6 Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. Client Communication \u00b6 Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. Methods \u00b6 Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points ) Signals (Server-to-Client) \u00b6 We should also create a signal that we can fire events for the clients when their points change. We can use the RemoteSignal module ( Knit.Util.Remote.RemoteSignal ), and just put one within the Client table: 1 PointsService . Client . PointsChanged = RemoteSignal . new () Under the hood, Knit is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client signal: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for an event on the signal: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end ) Note Be sure to use RemoteSignal ( not Signal ) for client-exposed events. Signals (Client-to-Server) \u00b6 Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: 1 PointsService . Client . GiveMePoints = RemoteSignal . new () Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this signal, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the signal like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the signal: PointsService . GiveMePoints : Fire () Properties \u00b6 Knit provides a RemoteProperty module to easily expose values to the client. These values are read-only on the client. For our example, let's say that we want to show the most points in the game. First, let's create the RemoteProperty object: 1 2 3 local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) PointsService . MostPoints = RemoteProperty . new ( 0 ) Now, let's change this object whenever we add points: 1 2 3 4 5 6 7 8 function PointsService : AddPoints ( player , amount ) -- Other code from before... -- Set MostPoints value: if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end On the server, the RemoteProperty object has Set and Get methods, and also has a Changed event. On the client, it only has the Get method and Changed event (no Set method on the client; read-only). Let's grab this value on the client: 1 2 3 4 5 6 7 8 9 10 11 12 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Grab value: local mostPoints = PointsService . MostPoints : Get () -- Keep it updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) Full Example \u00b6 PointsService \u00b6 At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local RemoteSignal = require ( Knit . Util . Remote . RemoteSignal ) local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed signals/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Signal . new () -- Client exposed signals: PointsService . Client . PointsChanged = RemoteSignal . new () PointsService . Client . GiveMePoints = RemoteSignal . new () -- Client exposed properties: PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Signal . new (); Client = { PointsChanged = RemoteSignal . new (); GiveMePoints = RemoteSignal . new (); }; } -- The rest of code here Client Consumer \u00b6 Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Grab MostPoints value: local mostPoints = PointsService . MostPoints : Get () -- Keep MostPoints value updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): Then ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Services"},{"location":"services/#services-defined","text":"Services are singleton objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page.","title":"Services Defined"},{"location":"services/#creating-services","text":"In its simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services.","title":"Creating Services"},{"location":"services/#adding-methods","text":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end","title":"Adding methods"},{"location":"services/#adding-properties","text":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {}","title":"Adding properties"},{"location":"services/#using-methods-and-properties","text":"Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points += amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end","title":"Using methods and properties"},{"location":"services/#using-events","text":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Signal module and create PointsChanged signal: local Signal = require ( Knit . Util . Signal ) PointsService . PointsChanged = Signal . new () -- Modify AddPoints: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points -- Fire event signal, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end","title":"Using events"},{"location":"services/#knitinit-and-knitstart","text":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up you service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use.","title":"KnitInit and KnitStart"},{"location":"services/#cleaning-up-unused-memory","text":"Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer.","title":"Cleaning Up Unused Memory"},{"location":"services/#client-communication","text":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning.","title":"Client Communication"},{"location":"services/#methods","text":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points )","title":"Methods"},{"location":"services/#signals-server-to-client","text":"We should also create a signal that we can fire events for the clients when their points change. We can use the RemoteSignal module ( Knit.Util.Remote.RemoteSignal ), and just put one within the Client table: 1 PointsService . Client . PointsChanged = RemoteSignal . new () Under the hood, Knit is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client signal: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for an event on the signal: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end ) Note Be sure to use RemoteSignal ( not Signal ) for client-exposed events.","title":"Signals (Server-to-Client)"},{"location":"services/#signals-client-to-server","text":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: 1 PointsService . Client . GiveMePoints = RemoteSignal . new () Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this signal, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the signal like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the signal: PointsService . GiveMePoints : Fire ()","title":"Signals (Client-to-Server)"},{"location":"services/#properties","text":"Knit provides a RemoteProperty module to easily expose values to the client. These values are read-only on the client. For our example, let's say that we want to show the most points in the game. First, let's create the RemoteProperty object: 1 2 3 local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) PointsService . MostPoints = RemoteProperty . new ( 0 ) Now, let's change this object whenever we add points: 1 2 3 4 5 6 7 8 function PointsService : AddPoints ( player , amount ) -- Other code from before... -- Set MostPoints value: if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end On the server, the RemoteProperty object has Set and Get methods, and also has a Changed event. On the client, it only has the Get method and Changed event (no Set method on the client; read-only). Let's grab this value on the client: 1 2 3 4 5 6 7 8 9 10 11 12 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Grab value: local mostPoints = PointsService . MostPoints : Get () -- Keep it updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end )","title":"Properties"},{"location":"services/#full-example","text":"","title":"Full Example"},{"location":"services/#pointsservice","text":"At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local RemoteSignal = require ( Knit . Util . Remote . RemoteSignal ) local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed signals/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Signal . new () -- Client exposed signals: PointsService . Client . PointsChanged = RemoteSignal . new () PointsService . Client . GiveMePoints = RemoteSignal . new () -- Client exposed properties: PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Signal . new (); Client = { PointsChanged = RemoteSignal . new (); GiveMePoints = RemoteSignal . new (); }; } -- The rest of code here","title":"PointsService"},{"location":"services/#client-consumer","text":"Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Grab MostPoints value: local mostPoints = PointsService . MostPoints : Get () -- Keep MostPoints value updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): Then ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Client Consumer"},{"location":"styleguide/","text":"Knit Style Guide \u00b6 For those who want to contribute to Knit, here are some guidelines in regards to code style. Readability \u00b6 Readability is king. Code within Knit should not be impressive; it should be readable. Having readable code is important for debugging and future maintainability. This also means that code shouldn't be prematurely optimized with fancy Lua tricks unless absolutely necessary. In almost all cases, such optimizations only make the code unreadable and add no real value. Single Purpose Files \u00b6 Every source file within Knit should have a single purpose. This might be a single class, table, function, etc. For instance, a source file should not contain a bunch of public classes. Split these into separate files. File Structure \u00b6 File names should match the name of the module. All source files should follow a similar format to this template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Header (author, date, etc.) -- Documentation -- Module requires (e.g. Module = require(somewhere.Module)) -- Service refs (e.g. RunService = game:GetService(\"RunService\")) -- Constants (e.g. MY_CONSTANT = 10) -- Variables (although, global vars are looked down upon) -- Module definition (e.g. MyModule = {}) -- Module code -- Return module Example of MyModule.lua : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -- MyModule -- John Doe -- January 10, 2021 --[[ MyModule.DoSomething(value: number) MyModule.DoAnotherThing() MyModule.DidSomething(value: number) --]] local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local HttpService = require ( \"HttpService\" ) local MESSAGE = \"Hello\" local MyModule = {} MyModule . DidSomething = Signal . new () function MyModule . DoSomething ( value ) -- Do something MyModule . DidSomething : Fire ( value ) end function MyModule . DoAnotherThing () -- Do something else end return MyModule Spacing \u00b6 Between each section above, there should be a blank line of separation. Two blank lines should exist around methods and functions. Variables \u00b6 Variables should be descriptive and should be written in camelCase . 1 local amountLeft = 10 Constants \u00b6 Variables that should act as constants (non-changing variables) should be written in UPPER_SNAKE_CASE . 1 2 local MAX_INTERVAL = 20 local DEFAULT_TEXT = \"Hello\" Services and Requires \u00b6 Services retrieved using game:GetService or modules retrieved using require should be written in PascalCase . 1 2 local Signal = require ( Knit . Util . Signal ) local RunService = game : GetService ( \"RunService\" ) Functions \u00b6 Function names should be written in PascalCase and declared with local if possible. Functions should be short and easy to understand. When possible, prefer functional programming techniques, so that side effects are avoided. In other words, functions should only manipulate the variables within the function or passed as arguments, and the function should not change any variables outside of the function's scope. 1 2 3 4 local function HelloWorld ( message ) local newMessage = \"The message was: \" .. message return newMessage end Classes \u00b6 Classes should be defined with the following boilerplate code: 1 2 3 4 5 6 7 8 9 10 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end It is important that classes have a Destroy method so that they can be passed to Maids for cleanup. Method & Field Names \u00b6 Public method and field names should be written in PascalCase . Private method and field names should be written in _underscoreCamelCase . Fields should be declared within the new constructor. For readability, it is preferred to add the fields after the setmetatable line. Please note that it is technically faster to declare fields within the table declaration, but readability is key. Only the class itself should ever access private methods or fields. If other code is accessing these methods or fields, it is probably due to bad design. Switch those methods/fields to be public or redesign how those items are being accessed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function MyClass . new () local self = setmetatable ({}, MyClass ) self . MyPublicField = \"Hello world\" self . _myPrivateField = \"Goodbye earth\" return self end function MyClass : SomeMethod () local combined = ( self . MyPublicField .. \" \" .. self . _myPrivateField ) return combined end function MyClass : _somePrivateMethod () return self . MyPublicField : rep ( 10 ) end Public or Private \u00b6 When deciding if a method or field should be public or private, ask these questions: Does the method/field need to be accessed by code outside of this class? If yes, the method/field should be public. If no, keep it private. Simply underscoring the name of a method/field gives no actual security to those methods/fields. It is only a convention. It helps authors know if they should be accessing the methods/fields. An assumption can be made that accessing or manipulating private methods/fields is bad and can result in unexpected behavior, and is thus better avoided. Method or Function \u00b6 It is important to decide whether a piece of code should exist as a method or as a function. This can be figured out quite simply: Is is required that external code can invoke this function, and does it need any information about the object itself? If the answer is \"no\" to both of these questions, then it should exist as a standalone function. Standalone functions in class modules should be defined above the class definition. Documentation \u00b6 At the top of each source file, simple documentation should be given to show how to use the module. This should show method signatures, fields, and events. If needed, short examples of usage can be shown too. While Lua is a dynamic language, it is helpful to include types for arguments and return values. For instance: Symbol.Is(obj: any): boolean , which shows that obj can be any type, and a boolean is the expected return type. The typical layout is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 --[[ -- CONSTRUCTOR DEFINITIONS -- -- FIELD DEFINITIONS -- -- METHOD DEFINITIONS -- -- EVENT DEFINITIONS -- -- EXAMPLES IF NEEDED -- --]] Example: 1 2 3 4 5 6 7 8 9 --[[ myClass = MyClass.new() myClass.MyPublicField: string myClass:SomeMethod(): string --]] Other Material \u00b6 Outside of styling defined in this guide, follow the Roblox Lua Style Guide .","title":"Style Guide"},{"location":"styleguide/#knit-style-guide","text":"For those who want to contribute to Knit, here are some guidelines in regards to code style.","title":"Knit Style Guide"},{"location":"styleguide/#readability","text":"Readability is king. Code within Knit should not be impressive; it should be readable. Having readable code is important for debugging and future maintainability. This also means that code shouldn't be prematurely optimized with fancy Lua tricks unless absolutely necessary. In almost all cases, such optimizations only make the code unreadable and add no real value.","title":"Readability"},{"location":"styleguide/#single-purpose-files","text":"Every source file within Knit should have a single purpose. This might be a single class, table, function, etc. For instance, a source file should not contain a bunch of public classes. Split these into separate files.","title":"Single Purpose Files"},{"location":"styleguide/#file-structure","text":"File names should match the name of the module. All source files should follow a similar format to this template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Header (author, date, etc.) -- Documentation -- Module requires (e.g. Module = require(somewhere.Module)) -- Service refs (e.g. RunService = game:GetService(\"RunService\")) -- Constants (e.g. MY_CONSTANT = 10) -- Variables (although, global vars are looked down upon) -- Module definition (e.g. MyModule = {}) -- Module code -- Return module Example of MyModule.lua : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -- MyModule -- John Doe -- January 10, 2021 --[[ MyModule.DoSomething(value: number) MyModule.DoAnotherThing() MyModule.DidSomething(value: number) --]] local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local HttpService = require ( \"HttpService\" ) local MESSAGE = \"Hello\" local MyModule = {} MyModule . DidSomething = Signal . new () function MyModule . DoSomething ( value ) -- Do something MyModule . DidSomething : Fire ( value ) end function MyModule . DoAnotherThing () -- Do something else end return MyModule","title":"File Structure"},{"location":"styleguide/#spacing","text":"Between each section above, there should be a blank line of separation. Two blank lines should exist around methods and functions.","title":"Spacing"},{"location":"styleguide/#variables","text":"Variables should be descriptive and should be written in camelCase . 1 local amountLeft = 10","title":"Variables"},{"location":"styleguide/#constants","text":"Variables that should act as constants (non-changing variables) should be written in UPPER_SNAKE_CASE . 1 2 local MAX_INTERVAL = 20 local DEFAULT_TEXT = \"Hello\"","title":"Constants"},{"location":"styleguide/#services-and-requires","text":"Services retrieved using game:GetService or modules retrieved using require should be written in PascalCase . 1 2 local Signal = require ( Knit . Util . Signal ) local RunService = game : GetService ( \"RunService\" )","title":"Services and Requires"},{"location":"styleguide/#functions","text":"Function names should be written in PascalCase and declared with local if possible. Functions should be short and easy to understand. When possible, prefer functional programming techniques, so that side effects are avoided. In other words, functions should only manipulate the variables within the function or passed as arguments, and the function should not change any variables outside of the function's scope. 1 2 3 4 local function HelloWorld ( message ) local newMessage = \"The message was: \" .. message return newMessage end","title":"Functions"},{"location":"styleguide/#classes","text":"Classes should be defined with the following boilerplate code: 1 2 3 4 5 6 7 8 9 10 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end It is important that classes have a Destroy method so that they can be passed to Maids for cleanup.","title":"Classes"},{"location":"styleguide/#method-field-names","text":"Public method and field names should be written in PascalCase . Private method and field names should be written in _underscoreCamelCase . Fields should be declared within the new constructor. For readability, it is preferred to add the fields after the setmetatable line. Please note that it is technically faster to declare fields within the table declaration, but readability is key. Only the class itself should ever access private methods or fields. If other code is accessing these methods or fields, it is probably due to bad design. Switch those methods/fields to be public or redesign how those items are being accessed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function MyClass . new () local self = setmetatable ({}, MyClass ) self . MyPublicField = \"Hello world\" self . _myPrivateField = \"Goodbye earth\" return self end function MyClass : SomeMethod () local combined = ( self . MyPublicField .. \" \" .. self . _myPrivateField ) return combined end function MyClass : _somePrivateMethod () return self . MyPublicField : rep ( 10 ) end","title":"Method &amp; Field Names"},{"location":"styleguide/#public-or-private","text":"When deciding if a method or field should be public or private, ask these questions: Does the method/field need to be accessed by code outside of this class? If yes, the method/field should be public. If no, keep it private. Simply underscoring the name of a method/field gives no actual security to those methods/fields. It is only a convention. It helps authors know if they should be accessing the methods/fields. An assumption can be made that accessing or manipulating private methods/fields is bad and can result in unexpected behavior, and is thus better avoided.","title":"Public or Private"},{"location":"styleguide/#method-or-function","text":"It is important to decide whether a piece of code should exist as a method or as a function. This can be figured out quite simply: Is is required that external code can invoke this function, and does it need any information about the object itself? If the answer is \"no\" to both of these questions, then it should exist as a standalone function. Standalone functions in class modules should be defined above the class definition.","title":"Method or Function"},{"location":"styleguide/#documentation","text":"At the top of each source file, simple documentation should be given to show how to use the module. This should show method signatures, fields, and events. If needed, short examples of usage can be shown too. While Lua is a dynamic language, it is helpful to include types for arguments and return values. For instance: Symbol.Is(obj: any): boolean , which shows that obj can be any type, and a boolean is the expected return type. The typical layout is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 --[[ -- CONSTRUCTOR DEFINITIONS -- -- FIELD DEFINITIONS -- -- METHOD DEFINITIONS -- -- EVENT DEFINITIONS -- -- EXAMPLES IF NEEDED -- --]] Example: 1 2 3 4 5 6 7 8 9 --[[ myClass = MyClass.new() myClass.MyPublicField: string myClass:SomeMethod(): string --]]","title":"Documentation"},{"location":"styleguide/#other-material","text":"Outside of styling defined in this guide, follow the Roblox Lua Style Guide .","title":"Other Material"},{"location":"util/","text":"There are some utility modules that come prepackaged with Knit. These are used internally, but are also meant to be accessible to developers. These modules are accessible via Knit.Util and must be required, such as require(Knit.Util.Signal) . Signal \u00b6 The Signal module gives basic Roblox Signal functionality. It is easy to instantiate and use a signal object. 1 2 3 4 5 6 7 8 9 10 11 12 local Signal = require ( Knit . Util . Signal ) local signal = Signal . new () signal : Fire (...) signal : DisconnectAll () signal : Destroy () local connection = signal : Connect ( function (...) end ) connection . Connected connection : Disconnect () The Connection object internal to the Signal module also has a Destroy method associated with it, so it will still play nicely with the Maid module. Thread \u00b6 The Thread module aims to replace the somewhat-broken built-in thread functions (such as wait , spawn , and delay ), which suffer from throttling. 1 2 3 4 5 6 local Thread = require ( Knit . Util . Thread ) Thread . SpawnNow ( function () print ( \"Hello\" ) end ) Thread . Spawn ( function () print ( \"Hi\" ) end ) Thread . Delay ( 1 , function () print ( \"Hola\" ) end ) Thread . DelayRepeat ( 1 , function () print ( \"Hello again\" ) end ) DelayRepeat has an optional Behavior parameter, which can be used to switch the behavior between an initial delay (default) or immediate execution before the first delay. For instance, if you want the function to fire immediately before starting the delay loop, use the Immediate behavior: 1 2 3 4 5 6 7 8 9 -- Fire the function immediately: Thread . DelayRepeat ( 1 , function () print ( \"Hello\" ) end , Thread . DelayRepeatBehavior . Immediate ) -- Fire the function after the first 1 second delay (default behavior): Thread . DelayRepeat ( 1 , function () print ( \"Hello\" ) end , Thread . DelayRepeatBehavior . Delayed ) All of these functions can also be given arguments, as a vararg list at the end of the Thread function call. For instance: 1 2 3 Thread . Spawn ( function ( someMessage ) print ( someMessage ) end , someMessage ) The caveat with the above is dealing with DelayRepeat, where the behavior must first be defined before the vararg list: 1 2 3 4 5 6 7 8 9 -- Will work: Thread . DelayRepeat ( 1 , function ( message ) print ( message ) end , Thread . DelayRepeatBehavior . Delayed , \"Hello world!\" ) -- Will throw an error as an unknown behavior: Thread . DelayRepeat ( 1 , function ( message ) print ( message ) end , \"Hello world!\" ) The Delay and DelayRepeat functions also return an event listener, so they can be cancelled if needed: 1 2 3 4 5 local delayConnection = Thread . Delay ( 10 , function () print ( \"I'll never see the light of day\" ) end ) delayConnection : Disconnect () Maid \u00b6 The Maid module is a powerful tool for tracking and cleaning up your messes (hence the name). The Maid module was created by James Onnen . Read his tutorial on Maids for a better understanding of how to use it. 1 2 3 4 5 6 7 8 9 10 11 12 local Maid = require ( Knit . Util . Maid ) local maid = Maid . new () -- Give tasks to be cleaned up at a later time: maid : GiveTask ( somePart ) maid : GiveTask ( something . SomeEvent : Connect ( function () end )) maid : GiveTask ( function () end ) -- Both Destroy and DoCleaning do the same thing: maid : Destroy () maid : DoCleaning () Any table with a Destroy method can be added to a maid. If you have a bunch of events that you've created for a custom class, using a maid would be good to clean them all up when you're done with the object. Typically a maid will live with the object with which contains the items being tracked. Promise \u00b6 The Promise module reproduces the behavior of Promises common in web programming, written by evaera . Promises are incredibly useful for managing asynchronous flows. Read the official documentation for usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local Promise = require ( Knit . Util . Promise ) local function Fetch ( url ) return Promise . new ( function ( resolve , reject ) local success , result = pcall ( function () return game : GetService ( \"HttpService\" ): GetAsync ( url ) end ) if ( success ) then resolve ( result ) else reject ( result ) end end ) end Fetch ( \"https://www.example.com\" ) : Then ( function ( result ) print ( result ) end ) : Catch ( function ( err ) warn ( err ) end ) RemoteSignal \u00b6 The RemoteSignal module wraps the RemoteEvent object and is typically used within services. The only time a developer should ever have to instantiate a RemoteSignal is within the Client table of a service. For use on the client, see ClientRemoteSignal. 1 2 3 4 5 6 7 8 9 10 11 local remoteSignal = RemoteSignal . new () remoteSignal : Fire ( player , ...) remoteSignal : FireExcept ( player , ...) remoteSignal : FireAll (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler ( player , ...)) connection : IsConnected () connection : Disconnect () ClientRemoteSignal \u00b6 The ClientRemoteSignal module wraps the RemoteEvent object and is typically used within services. Usually, ClientRemoteSignals are created behind-the-scenes and don't need to be instantiated by developers. However, it is available for developers in case custom workflows are being used. 1 2 3 4 5 6 7 8 9 local remoteSignal = ClientRemoteSignal . new ( remoteEventObject ) remoteSignal : Fire (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler (...)) connection : IsConnected () connection : Disconnect () RemoteProperty \u00b6 The RemoteProperty module wraps a ValueBase object to expose properties to the client from the server. The server can read and write to this object, but the client can only read. This is useful when it's overkill to write a combination of a method and event to replicate data to the client. When a RemoteProperty is created on the server, a value must be passed to the constructor. The type of the value will determine the ValueBase chosen. For instance, if a string is passed, it will instantiate a StringValue internally. The server can then set/get this value. On the client, a RemoteProperty must be instantiated by giving the ValueBase to the constructor. 1 2 3 4 5 local property = RemoteProperty . new ( 10 ) property : Set ( 30 ) property : Replicate () -- Only for table values local value = property : Get () property . Changed : Connect ( function ( newValue ) end ) Tables When using a table in a RemoteProperty, you must call property:Replicate() server-side after changing a value in the table in order for the changes to replicate to the client. This is necessary because there is no way to watch for changes on a table (unless you clutter it with a bunch of metatables). Calling Replicate will replicate the table to the clients. ClientRemoteProperty \u00b6 The ClientRemoteProperty module wraps a ValueBase object to expose properties from the server to the client. The client can only read the value. This class should be used alongside RemoteProperty on the server. Typically, developers will never need to instantiate ClientRemoteProperties, as they are automatically created for services on the client if the service has a RemoteProperty defined in its Client table. However, the class is exposed to developers in case custom workflows are being used. 1 2 3 4 -- Client-side local property = ClientRemoteProperty . new ( valueBaseObject ) local value = property : Get () property . Changed : Connect ( function ( newValue ) end ) Component \u00b6 The Component class allows developers to bind custom component classes to in-game objects based on tags provided by the CollectionService . For instance, a component might be created called DanceFloor , which has the purpose of making a part flash random colors. Here's what our DanceFloor component module might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local DanceFloor = {} DanceFloor . __index = DanceFloor -- How often the color changes: local UPDATE_INTERVAL = 0.5 function DanceFloor . new () local self = setmetatable ({}, DanceFloor ) self . _nextUpdate = time () + UPDATE_INTERVAL return self end function DanceFloor : HeartbeatUpdate ( dt ) if ( time () > self . _nextUpdate ) then -- Set the assigned instance to a random color: self . _instance . Color = Color3 . new ( math.random (), math.random (), math.random () ) self . _nextUpdate = self . _nextUpdate + UPDATE_INTERVAL end end function DanceFloor : Destroy () end return DanceFloor Now the Component module can be used to register the above component: 1 2 3 4 local Component = require ( Knit . Util . Component ) local DanceFloor = require ( somewhere . DanceFloor ) local danceFloor = Component . new ( \"DanceFloor\" , DanceFloor ) Lastly, simply assign parts within the game with the DanceFloor tag, and the DanceFloor component will automatically be instantiated for those objects. For editing tags within Studio, check out the Tag Editor plugin. The full API for components is listed within the Component module. Note If a component needs to be used on both the server and the client, it is recommended to make two separate component modules for each environment. In the above example, we made a DanceFloor. Ideally, such a module should only run on the client, since it is rapidly changing the color of the part at random. Another DanceFloor component could also be created for the server if desired. Option \u00b6 An Option is a powerful concept taken from Rust and other languages. The purpose is to represent an optional value. An option can either be Some or None . Using Options helps reduce nil bugs (which can cause silent bugs that can be hard to track down). Options automatically serialize/deserialize across the server/client boundary when passed through services or controllers. For full documentation, check out the LuaOption repository. Using Options is very simple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 local Option = require ( Knit . Util . Option ) -- Returns an Option: local function DoSomething () local rng = Random . new () local value = rng : NextNumber () if ( value > 0.5 ) then return Option . Some ( value ) else return Option . None end end -- Get option value: local value = DoSomething () -- Match if the value is 'some' or 'none': value : Match { Some = function ( value ) print ( \"Got value:\" , value ), None = function () print ( \"Got no value\" ) end } -- Optionally, use IsSome() and Unwrap(): if ( value : IsSome ()) then print ( \"Got value:\" , value : Unwrap ()) end Because these are automatically serialized/deserialized in services and controllers, they work great in cases where a returned result is uncertain: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- SERVICE: local MyService = Knit . CreateService { Name = \"MyService\" } local Option = require ( Knit . Util . Option ) function MyService . Client : GetWeapon ( player , weaponName ) local weapon = TryToGetWeaponSomehow ( player , weaponName ) if ( weapon ) then return Option . Some ( weapon ) else return Option . None end end ---- -- CONTROLLER: local MyController = Knit . CreateController { Name = \"MyController\" } function MyController : KnitStart () local MyService = Knit . GetService ( \"MyService\" ) local weaponOption = MyService : GetWeapon ( \"SomeWeapon\" ) weaponOption : Match { Some = function ( weapon ) --[[ Do something with weapon ]] end , None = function () warn ( \"No weapon found\" ) end } end Note Attempting to unwrap an option with no value will throw an error. This is intentional. The purpose is to avoid unhandled nil cases. Whenever calling Unwrap() , be sure that IsSome() was first checked. Using the Match pattern is the easiest way to handle both Some and None cases.","title":"Util"},{"location":"util/#signal","text":"The Signal module gives basic Roblox Signal functionality. It is easy to instantiate and use a signal object. 1 2 3 4 5 6 7 8 9 10 11 12 local Signal = require ( Knit . Util . Signal ) local signal = Signal . new () signal : Fire (...) signal : DisconnectAll () signal : Destroy () local connection = signal : Connect ( function (...) end ) connection . Connected connection : Disconnect () The Connection object internal to the Signal module also has a Destroy method associated with it, so it will still play nicely with the Maid module.","title":"Signal"},{"location":"util/#thread","text":"The Thread module aims to replace the somewhat-broken built-in thread functions (such as wait , spawn , and delay ), which suffer from throttling. 1 2 3 4 5 6 local Thread = require ( Knit . Util . Thread ) Thread . SpawnNow ( function () print ( \"Hello\" ) end ) Thread . Spawn ( function () print ( \"Hi\" ) end ) Thread . Delay ( 1 , function () print ( \"Hola\" ) end ) Thread . DelayRepeat ( 1 , function () print ( \"Hello again\" ) end ) DelayRepeat has an optional Behavior parameter, which can be used to switch the behavior between an initial delay (default) or immediate execution before the first delay. For instance, if you want the function to fire immediately before starting the delay loop, use the Immediate behavior: 1 2 3 4 5 6 7 8 9 -- Fire the function immediately: Thread . DelayRepeat ( 1 , function () print ( \"Hello\" ) end , Thread . DelayRepeatBehavior . Immediate ) -- Fire the function after the first 1 second delay (default behavior): Thread . DelayRepeat ( 1 , function () print ( \"Hello\" ) end , Thread . DelayRepeatBehavior . Delayed ) All of these functions can also be given arguments, as a vararg list at the end of the Thread function call. For instance: 1 2 3 Thread . Spawn ( function ( someMessage ) print ( someMessage ) end , someMessage ) The caveat with the above is dealing with DelayRepeat, where the behavior must first be defined before the vararg list: 1 2 3 4 5 6 7 8 9 -- Will work: Thread . DelayRepeat ( 1 , function ( message ) print ( message ) end , Thread . DelayRepeatBehavior . Delayed , \"Hello world!\" ) -- Will throw an error as an unknown behavior: Thread . DelayRepeat ( 1 , function ( message ) print ( message ) end , \"Hello world!\" ) The Delay and DelayRepeat functions also return an event listener, so they can be cancelled if needed: 1 2 3 4 5 local delayConnection = Thread . Delay ( 10 , function () print ( \"I'll never see the light of day\" ) end ) delayConnection : Disconnect ()","title":"Thread"},{"location":"util/#maid","text":"The Maid module is a powerful tool for tracking and cleaning up your messes (hence the name). The Maid module was created by James Onnen . Read his tutorial on Maids for a better understanding of how to use it. 1 2 3 4 5 6 7 8 9 10 11 12 local Maid = require ( Knit . Util . Maid ) local maid = Maid . new () -- Give tasks to be cleaned up at a later time: maid : GiveTask ( somePart ) maid : GiveTask ( something . SomeEvent : Connect ( function () end )) maid : GiveTask ( function () end ) -- Both Destroy and DoCleaning do the same thing: maid : Destroy () maid : DoCleaning () Any table with a Destroy method can be added to a maid. If you have a bunch of events that you've created for a custom class, using a maid would be good to clean them all up when you're done with the object. Typically a maid will live with the object with which contains the items being tracked.","title":"Maid"},{"location":"util/#promise","text":"The Promise module reproduces the behavior of Promises common in web programming, written by evaera . Promises are incredibly useful for managing asynchronous flows. Read the official documentation for usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local Promise = require ( Knit . Util . Promise ) local function Fetch ( url ) return Promise . new ( function ( resolve , reject ) local success , result = pcall ( function () return game : GetService ( \"HttpService\" ): GetAsync ( url ) end ) if ( success ) then resolve ( result ) else reject ( result ) end end ) end Fetch ( \"https://www.example.com\" ) : Then ( function ( result ) print ( result ) end ) : Catch ( function ( err ) warn ( err ) end )","title":"Promise"},{"location":"util/#remotesignal","text":"The RemoteSignal module wraps the RemoteEvent object and is typically used within services. The only time a developer should ever have to instantiate a RemoteSignal is within the Client table of a service. For use on the client, see ClientRemoteSignal. 1 2 3 4 5 6 7 8 9 10 11 local remoteSignal = RemoteSignal . new () remoteSignal : Fire ( player , ...) remoteSignal : FireExcept ( player , ...) remoteSignal : FireAll (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler ( player , ...)) connection : IsConnected () connection : Disconnect ()","title":"RemoteSignal"},{"location":"util/#clientremotesignal","text":"The ClientRemoteSignal module wraps the RemoteEvent object and is typically used within services. Usually, ClientRemoteSignals are created behind-the-scenes and don't need to be instantiated by developers. However, it is available for developers in case custom workflows are being used. 1 2 3 4 5 6 7 8 9 local remoteSignal = ClientRemoteSignal . new ( remoteEventObject ) remoteSignal : Fire (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler (...)) connection : IsConnected () connection : Disconnect ()","title":"ClientRemoteSignal"},{"location":"util/#remoteproperty","text":"The RemoteProperty module wraps a ValueBase object to expose properties to the client from the server. The server can read and write to this object, but the client can only read. This is useful when it's overkill to write a combination of a method and event to replicate data to the client. When a RemoteProperty is created on the server, a value must be passed to the constructor. The type of the value will determine the ValueBase chosen. For instance, if a string is passed, it will instantiate a StringValue internally. The server can then set/get this value. On the client, a RemoteProperty must be instantiated by giving the ValueBase to the constructor. 1 2 3 4 5 local property = RemoteProperty . new ( 10 ) property : Set ( 30 ) property : Replicate () -- Only for table values local value = property : Get () property . Changed : Connect ( function ( newValue ) end ) Tables When using a table in a RemoteProperty, you must call property:Replicate() server-side after changing a value in the table in order for the changes to replicate to the client. This is necessary because there is no way to watch for changes on a table (unless you clutter it with a bunch of metatables). Calling Replicate will replicate the table to the clients.","title":"RemoteProperty"},{"location":"util/#clientremoteproperty","text":"The ClientRemoteProperty module wraps a ValueBase object to expose properties from the server to the client. The client can only read the value. This class should be used alongside RemoteProperty on the server. Typically, developers will never need to instantiate ClientRemoteProperties, as they are automatically created for services on the client if the service has a RemoteProperty defined in its Client table. However, the class is exposed to developers in case custom workflows are being used. 1 2 3 4 -- Client-side local property = ClientRemoteProperty . new ( valueBaseObject ) local value = property : Get () property . Changed : Connect ( function ( newValue ) end )","title":"ClientRemoteProperty"},{"location":"util/#component","text":"The Component class allows developers to bind custom component classes to in-game objects based on tags provided by the CollectionService . For instance, a component might be created called DanceFloor , which has the purpose of making a part flash random colors. Here's what our DanceFloor component module might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local DanceFloor = {} DanceFloor . __index = DanceFloor -- How often the color changes: local UPDATE_INTERVAL = 0.5 function DanceFloor . new () local self = setmetatable ({}, DanceFloor ) self . _nextUpdate = time () + UPDATE_INTERVAL return self end function DanceFloor : HeartbeatUpdate ( dt ) if ( time () > self . _nextUpdate ) then -- Set the assigned instance to a random color: self . _instance . Color = Color3 . new ( math.random (), math.random (), math.random () ) self . _nextUpdate = self . _nextUpdate + UPDATE_INTERVAL end end function DanceFloor : Destroy () end return DanceFloor Now the Component module can be used to register the above component: 1 2 3 4 local Component = require ( Knit . Util . Component ) local DanceFloor = require ( somewhere . DanceFloor ) local danceFloor = Component . new ( \"DanceFloor\" , DanceFloor ) Lastly, simply assign parts within the game with the DanceFloor tag, and the DanceFloor component will automatically be instantiated for those objects. For editing tags within Studio, check out the Tag Editor plugin. The full API for components is listed within the Component module. Note If a component needs to be used on both the server and the client, it is recommended to make two separate component modules for each environment. In the above example, we made a DanceFloor. Ideally, such a module should only run on the client, since it is rapidly changing the color of the part at random. Another DanceFloor component could also be created for the server if desired.","title":"Component"},{"location":"util/#option","text":"An Option is a powerful concept taken from Rust and other languages. The purpose is to represent an optional value. An option can either be Some or None . Using Options helps reduce nil bugs (which can cause silent bugs that can be hard to track down). Options automatically serialize/deserialize across the server/client boundary when passed through services or controllers. For full documentation, check out the LuaOption repository. Using Options is very simple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 local Option = require ( Knit . Util . Option ) -- Returns an Option: local function DoSomething () local rng = Random . new () local value = rng : NextNumber () if ( value > 0.5 ) then return Option . Some ( value ) else return Option . None end end -- Get option value: local value = DoSomething () -- Match if the value is 'some' or 'none': value : Match { Some = function ( value ) print ( \"Got value:\" , value ), None = function () print ( \"Got no value\" ) end } -- Optionally, use IsSome() and Unwrap(): if ( value : IsSome ()) then print ( \"Got value:\" , value : Unwrap ()) end Because these are automatically serialized/deserialized in services and controllers, they work great in cases where a returned result is uncertain: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- SERVICE: local MyService = Knit . CreateService { Name = \"MyService\" } local Option = require ( Knit . Util . Option ) function MyService . Client : GetWeapon ( player , weaponName ) local weapon = TryToGetWeaponSomehow ( player , weaponName ) if ( weapon ) then return Option . Some ( weapon ) else return Option . None end end ---- -- CONTROLLER: local MyController = Knit . CreateController { Name = \"MyController\" } function MyController : KnitStart () local MyService = Knit . GetService ( \"MyService\" ) local weaponOption = MyService : GetWeapon ( \"SomeWeapon\" ) weaponOption : Match { Some = function ( weapon ) --[[ Do something with weapon ]] end , None = function () warn ( \"No weapon found\" ) end } end Note Attempting to unwrap an option with no value will throw an error. This is intentional. The purpose is to avoid unhandled nil cases. Whenever calling Unwrap() , be sure that IsSome() was first checked. Using the Match pattern is the easiest way to handle both Some and None cases.","title":"Option"},{"location":"vscodesnippets/","text":"Being able to quickly create services, controllers, or other Knit-related items is very useful when using Knit as a framework. To keep Knit lightweight, there are no required extensions or plugins. Instead, below are some VS Code snippets that can be used to speed up development. Using Snippets \u00b6 Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -> Preferences -> User Snippets Type in and select lua.json Within the {} braces, include any or all of the snippets below Save the file Within your actual source files, start typing a prefix (e.g. \"knit\") and select the autocompleted snippet to paste it in Depending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service) Knit Snippets \u00b6 Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. Knit \u00b6 Include a require statement for Knit. Snippet 1 2 3 4 5 \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" } Code Result 1 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Service \u00b6 Reference a Roblox service. Snippet 1 2 3 4 5 \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" } Code Result 1 local HttpService = game : GetService ( \"HttpService\" ) Knit Service \u00b6 Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyService = Knit . CreateService { Name = \"MyService\" ; Client = {}; } function MyService : KnitStart () end function MyService : KnitInit () end return MyService Knit Controller \u00b6 Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyController = Knit . CreateController { Name = \"MyController\" ; } function MyController : KnitStart () end function MyController : KnitInit () end return MyController Knit Component \u00b6 Create a Knit component. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Maid = require(Knit.Util.Maid)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._maid = Maid.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._maid:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Maid = require ( Knit . Util . Maid ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _maid = Maid . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _maid : Destroy () end return MyComponent Knit Require \u00b6 Require a module within Knit. Snippet 1 2 3 4 5 \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local Maid = require ( Knit . Util . Maid ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _maid = Maid . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _maid : Destroy () end return MyComponent Lua Class \u00b6 A standard Lua class. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end return MyClass All \u00b6 All the above snippets together. All Snippets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 { \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" }, \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" }, \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" }, \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Maid = require(Knit.Util.Maid)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._maid = Maid.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._maid:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" }, \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" }, \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" }, \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } }","title":"VS Code Snippets"},{"location":"vscodesnippets/#using-snippets","text":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -> Preferences -> User Snippets Type in and select lua.json Within the {} braces, include any or all of the snippets below Save the file Within your actual source files, start typing a prefix (e.g. \"knit\") and select the autocompleted snippet to paste it in Depending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)","title":"Using Snippets"},{"location":"vscodesnippets/#knit-snippets","text":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage.","title":"Knit Snippets"},{"location":"vscodesnippets/#knit","text":"Include a require statement for Knit. Snippet 1 2 3 4 5 \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" } Code Result 1 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit )","title":"Knit"},{"location":"vscodesnippets/#service","text":"Reference a Roblox service. Snippet 1 2 3 4 5 \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" } Code Result 1 local HttpService = game : GetService ( \"HttpService\" )","title":"Service"},{"location":"vscodesnippets/#knit-service","text":"Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyService = Knit . CreateService { Name = \"MyService\" ; Client = {}; } function MyService : KnitStart () end function MyService : KnitInit () end return MyService","title":"Knit Service"},{"location":"vscodesnippets/#knit-controller","text":"Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyController = Knit . CreateController { Name = \"MyController\" ; } function MyController : KnitStart () end function MyController : KnitInit () end return MyController","title":"Knit Controller"},{"location":"vscodesnippets/#knit-component","text":"Create a Knit component. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Maid = require(Knit.Util.Maid)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._maid = Maid.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._maid:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Maid = require ( Knit . Util . Maid ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _maid = Maid . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _maid : Destroy () end return MyComponent","title":"Knit Component"},{"location":"vscodesnippets/#knit-require","text":"Require a module within Knit. Snippet 1 2 3 4 5 \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local Maid = require ( Knit . Util . Maid ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _maid = Maid . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _maid : Destroy () end return MyComponent","title":"Knit Require"},{"location":"vscodesnippets/#lua-class","text":"A standard Lua class. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end return MyClass","title":"Lua Class"},{"location":"vscodesnippets/#all","text":"All the above snippets together. All Snippets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 { \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" }, \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" }, \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" }, \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Maid = require(Knit.Util.Maid)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._maid = Maid.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._maid:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" }, \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" }, \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" }, \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } }","title":"All"},{"location":"whyknit/","text":"Why Knit? \u00b6 In Response to AGF \u00b6 Knit is a response to the underlying issues of AeroGameFramework (AGF). Some problems of AGF: Pigeon-holes developers into a specific code structure Hard to update and manage Hard to migrate existing code Not easy to share or distribute services/controllers Doesn't support code outside of structure Knit fixes these problems by having a modular structure. Knit can just be dropped in and used. It can be added to an existing codebase and slowly migrated. Anyone can write a plain module service/controller and distribute it to others. Knit still holds onto the core mission of AGF: Create an environment where modules of code can freely talk to each other in a structured manner, including crossing the server/client boundary. Structure (If you want) \u00b6 Knit gives developers the ability to create services and controllers, which gives a game structure. However, not all the code has to live in either of these two systems. Code can live alone and still consume services and controllers. Developers are free to organize codebases in any way. Framework / Library Hybrid \u00b6 While advertised as a game framework, Knit straddles the line between a framework and a library. While Knit provides optional structure using services and controllers, developers can choose if and how these structures are utilized. Developers are also responsible for creating the runtime scripts for Knit, which allows easy extensibility of the framework.","title":"Why Knit"},{"location":"whyknit/#why-knit","text":"","title":"Why Knit?"},{"location":"whyknit/#in-response-to-agf","text":"Knit is a response to the underlying issues of AeroGameFramework (AGF). Some problems of AGF: Pigeon-holes developers into a specific code structure Hard to update and manage Hard to migrate existing code Not easy to share or distribute services/controllers Doesn't support code outside of structure Knit fixes these problems by having a modular structure. Knit can just be dropped in and used. It can be added to an existing codebase and slowly migrated. Anyone can write a plain module service/controller and distribute it to others. Knit still holds onto the core mission of AGF: Create an environment where modules of code can freely talk to each other in a structured manner, including crossing the server/client boundary.","title":"In Response to AGF"},{"location":"whyknit/#structure-if-you-want","text":"Knit gives developers the ability to create services and controllers, which gives a game structure. However, not all the code has to live in either of these two systems. Code can live alone and still consume services and controllers. Developers are free to organize codebases in any way.","title":"Structure (If you want)"},{"location":"whyknit/#framework-library-hybrid","text":"While advertised as a game framework, Knit straddles the line between a framework and a library. While Knit provides optional structure using services and controllers, developers can choose if and how these structures are utilized. Developers are also responsible for creating the runtime scripts for Knit, which allows easy extensibility of the framework.","title":"Framework / Library Hybrid"}]}